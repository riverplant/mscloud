ä»€ä¹ˆæ˜¯ AQSï¼ˆAbstractQueuedSynchronizerï¼‰ï¼Ÿ
AQSï¼ˆAbstractQueuedSynchronizerï¼‰ æ˜¯ Java å¹¶å‘åŒ…ï¼ˆjava.util.concurrentï¼‰ 
ä¸­ç”¨äºŽ æž„å»ºé”å’ŒåŒæ­¥å™¨ çš„æ ¸å¿ƒæ¡†æž¶ã€‚

AQS é‡‡ç”¨ FIFOï¼ˆå…ˆè¿›å…ˆå‡ºï¼‰çš„ç­‰å¾…é˜Ÿåˆ— æ¥ ç®¡ç†å¤šä¸ªçº¿ç¨‹çš„è®¿é—®æŽ§åˆ¶ï¼Œ
ä¸ºè‡ªå®šä¹‰åŒæ­¥å™¨ï¼ˆå¦‚ ReentrantLock, Semaphore, CountDownLatchï¼‰ æä¾›äº†ä¸€ç§ é€šç”¨çš„åº•å±‚å®žçŽ°ã€‚

AQS çš„æ ¸å¿ƒæ¦‚å¿µ
AQS çš„æ ¸å¿ƒè®¾è®¡åŸºäºŽ é˜Ÿåˆ— + CASï¼ˆCompare-And-Swapï¼‰+ å…±äº«/ç‹¬å æ¨¡å¼ã€‚

1ï¸. stateï¼ˆåŒæ­¥çŠ¶æ€ï¼‰
AQS ç»´æŠ¤äº†ä¸€ä¸ª volatile å˜é‡ stateï¼Œè¡¨ç¤ºå½“å‰çš„ åŒæ­¥çŠ¶æ€ï¼š

state == 0 â†’ ä»£è¡¨é”æ˜¯ç©ºé—²çš„
state > 0 â†’ ä»£è¡¨é”è¢«å ç”¨ï¼ˆå¯èƒ½æ˜¯ç‹¬å é”æˆ–å…±äº«é”ï¼‰

state çš„ä¿®æ”¹æ–¹å¼

getState() èŽ·å–çŠ¶æ€
setState(int newState) è®¾ç½®çŠ¶æ€
compareAndSetState(int expect, int update) CAS æ–¹å¼æ›´æ–°çŠ¶æ€ï¼ˆä¹è§‚é”ï¼‰

ï¸. Nodeï¼ˆç­‰å¾…é˜Ÿåˆ—ï¼‰
AQS é‡‡ç”¨ CLH é˜Ÿåˆ—ï¼ˆFIFOï¼‰ æ¥å­˜å‚¨ ç­‰å¾…èŽ·å–é”çš„çº¿ç¨‹ï¼Œä»¥ åŒå‘é“¾è¡¨ çš„å½¢å¼ç»„ç»‡ï¼š

çº¿ç¨‹ç«žäº‰å¤±è´¥æ—¶ï¼Œä¼šè¢«å°è£…æˆ Node å¹¶åŠ å…¥ ç­‰å¾…é˜Ÿåˆ—
çº¿ç¨‹è¢«å”¤é†’æ—¶ï¼ŒæŒ‰ç…§ FIFO é¡ºåº èŽ·å–é”

æ‰€æœ‰çš„ç¶«ç¨‹æœƒè¢«å°è£çµ¦ä¸€å€‹Node!!!!!!!
static final class Node {
    volatile Node prev;  // å‰é©±èŠ‚ç‚¹
    volatile Node next;  // åŽç»§èŠ‚ç‚¹
    volatile Thread thread;  // çº¿ç¨‹
    volatile int waitStatus;  // çº¿ç¨‹ç­‰å¾…çŠ¶æ€
}

ç­‰å¾…çŠ¶æ€ waitStatusï¼š

çŠ¶æ€	è¯´æ˜Ž
SIGNAL(-1)	çº¿ç¨‹éœ€è¦è¢«å”¤é†’
CANCELLED(1)	çº¿ç¨‹ç­‰å¾…è¶…æ—¶æˆ–è¢«ä¸­æ–­
CONDITION(-2)	çº¿ç¨‹åœ¨ Condition ä¸‹ç­‰å¾…
PROPAGATE(-3)	å…±äº«æ¨¡å¼ä¸‹ï¼ŒçŠ¶æ€éœ€è¦ä¼ æ’­


acquire() å’Œ release()
AQS é€šè¿‡ acquire() å’Œ release() ç®¡ç†çº¿ç¨‹èŽ·å–å’Œé‡Šæ”¾åŒæ­¥çŠ¶æ€ã€‚

ðŸ“Œ ç‹¬å æ¨¡å¼ï¼ˆReentrantLockï¼‰

acquire(int arg) â†’ çº¿ç¨‹å°è¯•èŽ·å–é”ï¼Œå¤±è´¥åˆ™è¿›å…¥ç­‰å¾…é˜Ÿåˆ—
release(int arg) â†’ é‡Šæ”¾é”ï¼Œå”¤é†’ç­‰å¾…çš„çº¿ç¨‹


ðŸ“Œ å…±äº«æ¨¡å¼ï¼ˆSemaphore / CountDownLatchï¼‰

acquireShared(int arg) â†’ çº¿ç¨‹å°è¯•èŽ·å–å…±äº«èµ„æºï¼Œå¤±è´¥åˆ™è¿›å…¥é˜Ÿåˆ—
releaseShared(int arg) â†’ é‡Šæ”¾å…±äº«èµ„æºï¼Œå”¤é†’ä¸‹ä¸€ä¸ªçº¿ç¨‹


AQS æ˜¯ java.util.concurrent å¹¶å‘æ¡†æž¶çš„åŸºç¡€ï¼Œå¸¸è§çš„ åŸºäºŽ AQS å®žçŽ°çš„åŒæ­¥å™¨ åŒ…æ‹¬ï¼š

åŒæ­¥å™¨	ä½œç”¨
ReentrantLock	å¯é‡å…¥é”ï¼Œæ”¯æŒç‹¬å æ¨¡å¼
Semaphore	ä¿¡å·é‡ï¼Œæ”¯æŒå…±äº«æ¨¡å¼
CountDownLatch	è®¡æ•°å™¨ï¼Œç”¨äºŽå¤šä¸ªçº¿ç¨‹åŒæ­¥
CyclicBarrier	å¾ªçŽ¯æ …æ ï¼Œçº¿ç¨‹è¾¾åˆ°ä¸€å®šæ•°é‡åŽç»§ç»­æ‰§è¡Œ
ReadWriteLock	è¯»å†™é”ï¼Œæ”¯æŒè¯»å…±äº«ã€å†™ç‹¬å 


package com.riverplant.mscloud.javacore.aqs;

import java.util.concurrent.locks.AbstractQueuedSynchronizer;

public class MyLock {

	private static class Sync extends AbstractQueuedSynchronizer {

		@Override
		protected boolean tryAcquire(int arg) {
			if(compareAndSetState(0, 1)) {
				setExclusiveOwnerThread(Thread.currentThread());
				return true;
			}
			return false;
		}

		@Override
		protected boolean tryRelease(int arg) {
			if(getState() == 0) throw new IllegalMonitorStateException();
			setExclusiveOwnerThread(null);
			setState(0);
			return true;
		}

		@Override
		protected boolean isHeldExclusively() {
			return getState() == 1;
		}
		
	}
	
	private final Sync sync = new Sync();
	
	public void acquire() {
		sync.acquire(1);
		System.out.println(Thread.currentThread().getName()+"get lock");
	}
	
	public void release() {
		sync.release(1);
		System.out.println(Thread.currentThread().getName()+"release lock");
	}
}

// æµ‹è¯• MyLock
public class AQSDemo {
    private static final MyLock lock = new MyLock();

    public static void main(String[] args) {
        Runnable task = () -> {
            lock.acquire(1);
            System.out.println(Thread.currentThread().getName() + " èŽ·å–äº†é”");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.release(1);
                System.out.println(Thread.currentThread().getName() + " é‡Šæ”¾äº†é”");
            }
        };

        new Thread(task).start();
        new Thread(task).start();
    }
}


import java.util.concurrent.CountDownLatch;

public class CountDownLatchDemo {
    private static final CountDownLatch latch = new CountDownLatch(3);

    public static void main(String[] args) {
        Runnable task = () -> {
            System.out.println(Thread.currentThread().getName() + " æ‰§è¡Œä»»åŠ¡");
            latch.countDown(); // è®¡æ•°å‡ 1
        };

        // å¯åŠ¨ 3 ä¸ªçº¿ç¨‹
        new Thread(task).start();
        new Thread(task).start();
        new Thread(task).start();

        try {
            latch.await(); // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆ
            System.out.println("æ‰€æœ‰ä»»åŠ¡å·²å®Œæˆï¼");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

-------------------å¯é‡å…¥éŽ–-------------------------
stateè¡¨ç¤ºæž·éŽ–çš„æ¬¡æ•¸ï¼Œ0ç‚ºç„¡éŽ–ï¼Œæ¯åŠ ä¸€æ¬¡éŽ–state++, é‡‹æ”¾ä¸€æ¬¡å°±state--

CountDownLatch	å€’è®¡æ—¶ï¼Œç­‰æ‰€æœ‰ä»»åŠ¡å®ŒæˆåŽå†æ‰§è¡Œ	ä¸»çº¿ç¨‹ç­‰å¾…å¤šä¸ªä»»åŠ¡å®Œæˆ
Semaphore	ä¿¡å·é‡ï¼ŒæŽ§åˆ¶å¹¶å‘çº¿ç¨‹æ•°	é™æµæŽ§åˆ¶ï¼ˆå¦‚è¿žæŽ¥æ± ï¼‰
CyclicBarrier	çº¿ç¨‹å±éšœï¼Œç­‰æ‰€æœ‰çº¿ç¨‹åˆ°è¾¾å±éšœç‚¹å†ç»§ç»­	å¤šçº¿ç¨‹å¹¶è¡Œè®¡ç®—åŽåˆå¹¶ç»“æžœ

--------------------ABCä¸‰å€‹ç¶«ç¨‹åŒæ™‚åŸ·è¡Œã€ä¾æ¬¡åŸ·è¡Œå’Œäº¤éŒ¯åŸ·è¡Œ----------------
é—œæ–¼å¹¶ç™¼å·¥å…·ï¼š
countDownLatch: ä¸èƒ½ä¿è­‰æ‰€æœ‰ç¶«ç¨‹åŒæ™‚åŸ·è¡Œï¼Œå¯ä»¥ä¿è­‰æ‰€æœ‰çš„ä»»å‹™å®ŒæˆåŽä¸»ç¶«ç¨‹å†å¾€ä¸‹èµ°ã€‚
ä¾‹å¦‚æŸ¥è©¢å¤šå€‹æ•¸æ“šåº«çš„æ—¥å¿—åˆ†ç‰‡ï¼Œä¸»ç¶«ç¨‹ä½¿ç”¨latch.await()ç¢ºä¿æ‰€æœ‰çš„æŸ¥è©¢çµæžœéƒ½è¿”å›žåŽçµ±ä¸€è™•ç†æ•¸æ“šæœ€å¾Œè¿”å›žçµ¦å‰ç«¯
                
semaphore:   ä¾æ¬¡åŸ·è¡Œï¼Œé€²è¡Œäº†æŽ’åº  
cylicBarrier: æ‰€æœ‰ç¶«ç¨‹åŒæ™‚åŸ·è¡Œ

ä¾æ¬¡åŸ·è¡Œ: é€šéŽä¸€å€‹volatile int ticket = 1ä¾†æŽ§åˆ¶

volatile int ticket = 1
Thread t1 = new Thread(()->{
while(true) {
 if(ticket == 1){
   try{
      Thread.sleep(100);
      for(int i=0;i<10;i++) {
       System.out.println("a"+i);
      
      }
   
   }//try
   ticket = 2;
   
   return;
 
 
 }

}

})


Thread t2 = new Thread(()->{
while(true) {
 if(ticket == 2){
   try{
      Thread.sleep(100);
      for(int i=0;i<10;i++) {
       System.out.println("b"+i);
      
      }
   
   }//try
   ticket = 3;
   
   return;
 
 
 }

}

})

Thread t3 = new Thread(()->{
while(true) {
 if(ticket == 3){
   try{
      Thread.sleep(100);
      for(int i=0;i<10;i++) {
       System.out.println("c"+i);
      
      }
   
   }//try
   ticket = 1;
   
   return;
 
 
 }

}

})
------------------------å­—ç¬¦ä¸²å¿«é€ŸæŽ’åº---------------------------------------------------------------
Fork/Join!!!!

1.å°‡å¾ˆé•·çš„æ•¸çµ„åˆ†æˆå…©ä»½ï¼Œç„¶å¾Œåˆ†åˆ¥é€²è¡ŒæŽ’åº
2. å°‡æ•¸çµ„ç¹¼çºŒæ‹†åˆ†ã€‚ç›´åˆ°å‰©ä¸‹å…©å€‹æ•¸å­—æˆ–è€…ä¸€å€‹æ•¸å­—,ç„¶å¾Œé€²è¡ŒæŽ’åº
3. åŒ¯ç¸½çµæžœï¼Œå…ˆå¾žç¬¬ä¸€å€‹æ•¸çµ„çš„ç¬¬ä¸€å€‹å…ƒç´ é–‹å§‹èˆ‡ç¬¬äºŒå€‹æ•¸çµ„é€²è¡Œæ¯”è¼ƒï¼Œå“ªå€‹æ•¸çµ„çš„å€¼æ¯”è¼ƒå°å°±ç§»å‹•å“ªå€‹æ•¸çµ„çš„æŒ‡é‡






